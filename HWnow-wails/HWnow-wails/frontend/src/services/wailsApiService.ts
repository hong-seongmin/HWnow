// Wails API Service for native app communication
// This service replaces HTTP-based API calls with direct Wails runtime bindings

import type { Layout } from 'react-grid-layout';
import type { WidgetState, PageState } from '../stores/types';

// Type definitions for Wails API responses
export interface SystemInfoResponse {
  platform: string;
  cpu_cores: number;
  total_memory: number;
  boot_time: string;
}

export interface RealTimeMetricsResponse {
  cpu_usage: number;
  memory_usage: number;
  disk_usage: {
    total: number;
    used: number;
    free: number;
    usedPercent: number;
  };
  network_io: Array<{
    name: string;
    status: number;
    ipAddress: string;
    bytesRecv: number;
    bytesSent: number;
  }>;
  timestamp: string;
}

export interface GPUInfoResponse {
  name: string;
  usage: number;
  memory_used: number;
  memory_total: number;
  temperature: number;
}

export interface GPUProcessResponse {
  pid: number;
  name: string;
  memory_usage: number;
  gpu_usage: number;
}

export interface TopProcessResponse {
  pid: number;
  name: string;
  cpu_usage: number;
  memory_usage: number;
  memory_mb: number;
}

export interface WidgetApiResponse {
  success: boolean;
  message: string;
  userID: string;
  pageID: string;
  widgets: Array<{
    widgetId: string;
    widgetType: string;
    config: string;
    layout: string;
  }>;
  count?: number;
  widgetID?: string;
}

export interface PageApiResponse {
  success: boolean;
  message: string;
  userID: string;
  pageID?: string;
  pageName?: string;
  pages: Array<{
    pageId: string;
    pageName: string;
    pageOrder: number;
  }>;
}

export interface GPUProcessControlResponse {
  success: boolean;
  message: string;
  pid: number;
  operation: string;
  priority?: string;
}

// Wails runtime bindings (these will be generated by Wails)
declare global {
  interface Window {
    go: {
      main: {
        App: {
          // System monitoring methods
          GetSystemInfo(): Promise<SystemInfoResponse>;
          GetRealTimeMetrics(): Promise<RealTimeMetricsResponse>;
          GetGPUInfo(): Promise<GPUInfoResponse>;
          GetGPUProcesses(): Promise<GPUProcessResponse[]>;
          GetTopProcesses(count: number): Promise<TopProcessResponse[]>;
          StartMonitoring(): Promise<void>;
          StopMonitoring(): Promise<void>;
          IsMonitoringRunning(): Promise<boolean>;
          
          // GPU process control methods  
          KillGPUProcess(pid: number): Promise<GPUProcessControlResponse>;
          SuspendGPUProcess(pid: number): Promise<GPUProcessControlResponse>;
          ResumeGPUProcess(pid: number): Promise<GPUProcessControlResponse>;
          SetGPUProcessPriority(pid: number, priority: string): Promise<GPUProcessControlResponse>;
          ValidateGPUProcess(pid: number): Promise<{ isValid: boolean; message: string; pid: number; processName?: string }>;
          
          // Database methods
          GetWidgets(userID: string, pageID: string): Promise<WidgetApiResponse>;
          SaveWidgets(userID: string, pageID: string, widgets: Array<{ widgetId: string; widgetType: string; config: string; layout: string }>): Promise<WidgetApiResponse>;
          DeleteWidget(userID: string, pageID: string, widgetID: string): Promise<WidgetApiResponse>;
          GetPages(userID: string): Promise<PageApiResponse>;
          CreatePage(userID: string, pageID: string, pageName: string): Promise<PageApiResponse>;
          DeletePage(userID: string, pageID: string): Promise<PageApiResponse>;
          UpdatePageName(userID: string, pageID: string, newName: string): Promise<PageApiResponse>;
        };
      };
    };
  }
}

// Wails API Service Class with optimized architecture
export class WailsApiService {
  private static instance: WailsApiService;
  private isWailsAvailable: boolean = false;
  private retryConfig = {
    maxRetries: 3,
    baseDelayMs: 100,
    maxDelayMs: 2000
  };

  private constructor() {
    this.initializeService();
  }

  public static getInstance(): WailsApiService {
    if (!WailsApiService.instance) {
      WailsApiService.instance = new WailsApiService();
    }
    return WailsApiService.instance;
  }

  private initializeService(): void {
    this.checkWailsAvailability();
    if (typeof window !== 'undefined') {
      // Re-check availability on window load if not initially available
      if (!this.isWailsAvailable) {
        window.addEventListener('load', () => {
          this.checkWailsAvailability();
        });
      }
    }
  }

  private checkWailsAvailability(): void {
    this.isWailsAvailable = typeof window !== 'undefined' && 
                           typeof window.go !== 'undefined' && 
                           typeof window.go.main !== 'undefined' && 
                           typeof window.go.main.App !== 'undefined';
    
    if (this.isWailsAvailable) {
      console.log('[WailsAPI] Wails runtime detected and available');
    }
  }

  private ensureWailsAvailable(): void {
    // Re-check availability in case it became available after initialization
    if (!this.isWailsAvailable) {
      this.checkWailsAvailability();
    }
    
    if (!this.isWailsAvailable) {
      throw new Error('Wails runtime is not available. This service can only be used in a Wails application.');
    }
  }

  // Enhanced error handling wrapper with retry logic for transient failures
  private async executeWailsCall<T>(
    operation: () => Promise<T>,
    operationName: string,
    useRetry: boolean = false
  ): Promise<T> {
    this.ensureWailsAvailable();
    
    const execute = async (attempt: number = 1): Promise<T> => {
      try {
        const startTime = Date.now();
        const result = await operation();
        const duration = Date.now() - startTime;
        
        console.log(`[WailsAPI] ${operationName} completed in ${duration}ms (attempt ${attempt})`);
        return result;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        console.error(`[WailsAPI] ${operationName} failed (attempt ${attempt}):`, errorMessage);
        
        // Retry logic for transient failures
        if (useRetry && attempt < this.retryConfig.maxRetries) {
          const delay = Math.min(
            this.retryConfig.baseDelayMs * Math.pow(2, attempt - 1),
            this.retryConfig.maxDelayMs
          );
          
          console.warn(`[WailsAPI] Retrying ${operationName} in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          return execute(attempt + 1);
        }
        
        throw new Error(`${operationName} failed: ${errorMessage}`);
      }
    };
    
    return execute();
  }

  // Performance monitoring helpers
  private createPerformanceWrapper<T>(
    operation: () => Promise<T>,
    operationName: string
  ): () => Promise<T> {
    return async () => {
      const startTime = performance.now();
      try {
        const result = await operation();
        const duration = performance.now() - startTime;
        if (duration > 1000) { // Log slow operations
          console.warn(`[WailsAPI] Slow operation detected: ${operationName} took ${duration.toFixed(2)}ms`);
        }
        return result;
      } catch (error) {
        const duration = performance.now() - startTime;
        console.error(`[WailsAPI] Failed operation: ${operationName} failed after ${duration.toFixed(2)}ms`);
        throw error;
      }
    };
  }

  // System monitoring methods
  public async getSystemInfo(): Promise<SystemInfoResponse> {
    return this.executeWailsCall(
      this.createPerformanceWrapper(
        () => window.go.main.App.GetSystemInfo(),
        'GetSystemInfo'
      ),
      'GetSystemInfo',
      true
    );
  }

  public async getRealTimeMetrics(): Promise<RealTimeMetricsResponse> {
    return this.executeWailsCall(
      this.createPerformanceWrapper(
        () => window.go.main.App.GetRealTimeMetrics(),
        'GetRealTimeMetrics'
      ),
      'GetRealTimeMetrics',
      true
    );
  }

  public async getGPUInfo(): Promise<GPUInfoResponse> {
    return this.executeWailsCall(
      this.createPerformanceWrapper(
        () => window.go.main.App.GetGPUInfo(),
        'GetGPUInfo'
      ),
      'GetGPUInfo',
      false
    );
  }

  public async getGPUProcesses(): Promise<GPUProcessResponse[]> {
    return this.executeWailsCall(
      this.createPerformanceWrapper(
        () => window.go.main.App.GetGPUProcesses(),
        'GetGPUProcesses'
      ),
      'GetGPUProcesses',
      false
    );
  }

  public async getTopProcesses(count: number = 10): Promise<TopProcessResponse[]> {
    const validatedCount = this.validateProcessCount(count);
    
    return this.executeWailsCall(
      this.createPerformanceWrapper(
        () => window.go.main.App.GetTopProcesses(validatedCount),
        'GetTopProcesses'
      ),
      `GetTopProcesses(${validatedCount})`,
      false
    );
  }

  private validateProcessCount(count: number): number {
    if (typeof count !== 'number' || count <= 0) {
      console.warn(`[WailsAPI] Invalid process count: ${count}, using default: 10`);
      return 10;
    }
    if (count > 100) {
      console.warn(`[WailsAPI] Process count too high: ${count}, limiting to 100`);
      return 100;
    }
    return Math.floor(count);
  }

  public async startMonitoring(): Promise<{ success: boolean; message: string }> {
    try {
      await this.executeWailsCall(
        () => window.go.main.App.StartMonitoring(),
        'StartMonitoring'
      );
      return { success: true, message: 'Monitoring started successfully' };
    } catch (error) {
      return { success: false, message: error instanceof Error ? error.message : 'Failed to start monitoring' };
    }
  }

  public async stopMonitoring(): Promise<{ success: boolean; message: string }> {
    try {
      await this.executeWailsCall(
        () => window.go.main.App.StopMonitoring(),
        'StopMonitoring'
      );
      return { success: true, message: 'Monitoring stopped successfully' };
    } catch (error) {
      return { success: false, message: error instanceof Error ? error.message : 'Failed to stop monitoring' };
    }
  }

  public async isMonitoringRunning(): Promise<{ isRunning: boolean }> {
    try {
      const isRunning = await this.executeWailsCall(
        () => window.go.main.App.IsMonitoringRunning(),
        'IsMonitoringRunning'
      );
      return { isRunning };
    } catch (error) {
      console.error('Failed to check monitoring status:', error);
      return { isRunning: false };
    }
  }

  // GPU process control methods
  public async killGPUProcess(pid: number): Promise<GPUProcessControlResponse> {
    return this.executeWailsCall(
      () => window.go.main.App.KillGPUProcess(pid),
      `KillGPUProcess(${pid})`
    );
  }

  public async suspendGPUProcess(pid: number): Promise<GPUProcessControlResponse> {
    return this.executeWailsCall(
      () => window.go.main.App.SuspendGPUProcess(pid),
      `SuspendGPUProcess(${pid})`
    );
  }

  public async resumeGPUProcess(pid: number): Promise<GPUProcessControlResponse> {
    return this.executeWailsCall(
      () => window.go.main.App.ResumeGPUProcess(pid),
      `ResumeGPUProcess(${pid})`
    );
  }

  public async setGPUProcessPriority(pid: number, priority: string): Promise<GPUProcessControlResponse> {
    return this.executeWailsCall(
      () => window.go.main.App.SetGPUProcessPriority(pid, priority),
      `SetGPUProcessPriority(${pid}, ${priority})`
    );
  }

  public async validateGPUProcess(pid: number): Promise<{ isValid: boolean; message: string; pid: number; processName?: string }> {
    return this.executeWailsCall(
      () => window.go.main.App.ValidateGPUProcess(pid),
      `ValidateGPUProcess(${pid})`
    );
  }

  // Database methods with enhanced validation and error handling
  public async getWidgets(userID: string, pageID: string = 'main-page'): Promise<WidgetState[]> {
    // Input validation
    this.validateDatabaseInputs(userID, pageID);
    
    try {
      const response = await this.executeWailsCall(
        this.createPerformanceWrapper(
          () => window.go.main.App.GetWidgets(userID, pageID),
          'GetWidgets'
        ),
        `GetWidgets(${userID}, ${pageID})`,
        true // Enable retry for database operations
      );
      
      if (!response.success) {
        throw new Error(response.message);
      }
      
      // Convert Wails response to WidgetState format with safe parsing
      return response.widgets.map(widget => this.convertToWidgetState(widget, userID, pageID));
    } catch (error) {
      console.error(`Failed to get widgets for ${userID}/${pageID}:`, error);
      return [];
    }
  }

  // Utility methods for data conversion and validation
  private validateDatabaseInputs(userID: string, pageID: string): void {
    if (!userID || typeof userID !== 'string' || userID.trim().length === 0) {
      throw new Error('Invalid userID: must be a non-empty string');
    }
    if (!pageID || typeof pageID !== 'string' || pageID.trim().length === 0) {
      throw new Error('Invalid pageID: must be a non-empty string');
    }
    if (userID.length > 255) {
      throw new Error('userID too long: maximum 255 characters allowed');
    }
    if (pageID.length > 255) {
      throw new Error('pageID too long: maximum 255 characters allowed');
    }
  }

  private convertToWidgetState(widget: any, userID: string, pageID: string): WidgetState {
    return {
      userId: userID,
      pageId: pageID,
      widgetId: widget.widgetId,
      widgetType: widget.widgetType,
      config: this.safeJsonParse(widget.config, {}),
      layout: this.safeJsonParse(widget.layout, {})
    };
  }

  private safeJsonParse<T>(jsonString: string, defaultValue: T): T {
    try {
      return jsonString ? JSON.parse(jsonString) : defaultValue;
    } catch (error) {
      console.warn('Failed to parse JSON, using default value:', error);
      return defaultValue;
    }
  }

  public async saveWidgets(widgets: WidgetState[]): Promise<void> {
    if (widgets.length === 0) return;
    
    // Group widgets by userId and pageId
    const groupedWidgets = widgets.reduce((acc, widget) => {
      const key = `${widget.userId}:${widget.pageId}`;
      if (!acc[key]) {
        acc[key] = {
          userID: widget.userId,
          pageID: widget.pageId,
          widgets: []
        };
      }
      acc[key].widgets.push({
        widgetId: widget.widgetId,
        widgetType: widget.widgetType,
        config: JSON.stringify(widget.config || {}),
        layout: JSON.stringify(widget.layout || {})
      });
      return acc;
    }, {} as Record<string, { userID: string; pageID: string; widgets: Array<{ widgetId: string; widgetType: string; config: string; layout: string }> }>);

    // Save each group
    for (const group of Object.values(groupedWidgets)) {
      const response = await this.executeWailsCall(
        () => window.go.main.App.SaveWidgets(group.userID, group.pageID, group.widgets),
        `SaveWidgets(${group.userID}, ${group.pageID})`
      );
      
      if (!response.success) {
        throw new Error(response.message);
      }
    }
  }

  public async deleteWidget(userId: string, widgetId: string, pageId: string = 'main-page'): Promise<void> {
    const response = await this.executeWailsCall(
      () => window.go.main.App.DeleteWidget(userId, pageId, widgetId),
      `DeleteWidget(${userId}, ${pageId}, ${widgetId})`
    );
    
    if (!response.success) {
      throw new Error(response.message);
    }
  }

  public async getPages(userId: string): Promise<PageState[]> {
    try {
      const response = await this.executeWailsCall(
        () => window.go.main.App.GetPages(userId),
        `GetPages(${userId})`
      );
      
      if (!response.success) {
        throw new Error(response.message);
      }
      
      // Convert Wails response to PageState format
      return response.pages.map(page => ({
        userId: userId,
        pageId: page.pageId,
        pageName: page.pageName,
        pageOrder: page.pageOrder
      }));
    } catch (error) {
      console.error('Failed to get pages:', error);
      return [];
    }
  }

  public async createPage(userId: string, pageId: string, pageName: string): Promise<void> {
    const response = await this.executeWailsCall(
      () => window.go.main.App.CreatePage(userId, pageId, pageName),
      `CreatePage(${userId}, ${pageId}, ${pageName})`
    );
    
    if (!response.success) {
      throw new Error(response.message);
    }
  }

  public async deletePage(userId: string, pageId: string): Promise<void> {
    const response = await this.executeWailsCall(
      () => window.go.main.App.DeletePage(userId, pageId),
      `DeletePage(${userId}, ${pageId})`
    );
    
    if (!response.success) {
      throw new Error(response.message);
    }
  }

  public async updatePageName(userId: string, pageId: string, pageName: string): Promise<void> {
    const response = await this.executeWailsCall(
      () => window.go.main.App.UpdatePageName(userId, pageId, pageName),
      `UpdatePageName(${userId}, ${pageId}, ${pageName})`
    );
    
    if (!response.success) {
      throw new Error(response.message);
    }
  }

  // Dashboard layout methods (using existing widget system)
  public async getDashboardLayout(userId: string): Promise<Layout[]> {
    try {
      const widgets = await this.getWidgets(userId, 'main-page');
      return widgets.map(widget => widget.layout).filter(layout => layout && typeof layout === 'object');
    } catch (error) {
      console.error('Failed to get dashboard layout:', error);
      return [];
    }
  }

  public async saveDashboardLayout(userId: string, layout: Layout[]): Promise<void> {
    // This would require converting layout to widget format
    // For now, we'll log it as this needs more complex implementation
    console.log('Save dashboard layout:', { userId, layout });
  }

  // Privilege checking (placeholder - needs backend implementation)
  public async checkPrivileges(): Promise<{ hasAdminPrivileges: boolean; platform: string; message: string }> {
    try {
      const systemInfo = await this.getSystemInfo();
      return {
        hasAdminPrivileges: true, // TODO: Implement actual privilege check
        platform: systemInfo.platform,
        message: 'Privileges checked successfully'
      };
    } catch (error) {
      return {
        hasAdminPrivileges: false,
        platform: 'unknown',
        message: 'Failed to check privileges'
      };
    }
  }
}

// Export singleton instance
export const wailsApiService = WailsApiService.getInstance();

// Legacy function exports for compatibility
export const getSystemInfo = () => wailsApiService.getSystemInfo();
export const getRealTimeMetrics = () => wailsApiService.getRealTimeMetrics();
export const getGPUInfo = () => wailsApiService.getGPUInfo();
export const getGPUProcesses = () => wailsApiService.getGPUProcesses();
export const getTopProcesses = (count?: number) => wailsApiService.getTopProcesses(count);
export const startMonitoring = () => wailsApiService.startMonitoring();
export const stopMonitoring = () => wailsApiService.stopMonitoring();
export const isMonitoringRunning = () => wailsApiService.isMonitoringRunning();

export const killGPUProcess = (pid: number) => wailsApiService.killGPUProcess(pid);
export const suspendGPUProcess = (pid: number) => wailsApiService.suspendGPUProcess(pid);
export const resumeGPUProcess = (pid: number) => wailsApiService.resumeGPUProcess(pid);
export const setGPUProcessPriority = (pid: number, priority: string) => wailsApiService.setGPUProcessPriority(pid, priority);
export const validateGPUProcess = (pid: number) => wailsApiService.validateGPUProcess(pid);

export const getWidgets = (userId: string, pageId?: string) => wailsApiService.getWidgets(userId, pageId);
export const saveWidgets = (widgets: WidgetState[]) => wailsApiService.saveWidgets(widgets);
export const deleteWidget = (userId: string, widgetId: string, pageId?: string) => wailsApiService.deleteWidget(userId, widgetId, pageId);
export const getPages = (userId: string) => wailsApiService.getPages(userId);
export const createPage = (userId: string, pageId: string, pageName: string) => wailsApiService.createPage(userId, pageId, pageName);
export const deletePage = (userId: string, pageId: string) => wailsApiService.deletePage(userId, pageId);
export const updatePageName = (userId: string, pageId: string, pageName: string) => wailsApiService.updatePageName(userId, pageId, pageName);

export const getDashboardLayout = (userId: string) => wailsApiService.getDashboardLayout(userId);
export const saveDashboardLayout = (userId: string, layout: Layout[]) => wailsApiService.saveDashboardLayout(userId, layout);
export const checkPrivileges = () => wailsApiService.checkPrivileges();