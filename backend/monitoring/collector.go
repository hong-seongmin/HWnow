package monitoring

import (
	"fmt"
	"log"
	"time"

	"github.com/shirou/gopsutil/v3/cpu"
	"github.com/shirou/gopsutil/v3/disk"
	"github.com/shirou/gopsutil/v3/mem"
	"github.com/shirou/gopsutil/v3/net"
)

// Metric은 단일 모니터링 지표를 나타냅니다.
type Metric struct {
	Type  string
	Value float64
	Info  string // CPU 모델명 등 추가 정보
}

// ResourceSnapshot은 특정 시점의 모든 자원 사용량 스냅샷입니다.
type ResourceSnapshot struct {
	Timestamp time.Time
	Metrics   []Metric
}

// 모니터링을 위한 전역 변수
var (
	cpuInfoCounter int // CPU 정보 전송 카운터
)

// Start는 주기적으로 시스템 자원을 수집하여 채널로 전송하는 고루틴을 시작합니다.
// wsChan: WebSocket으로 실시간 전송하기 위한 채널
// dbChan: DB에 로그를 기록하기 위한 채널
func Start(wsChan chan<- *ResourceSnapshot, dbChan chan<- *ResourceSnapshot) {
	ticker := time.NewTicker(2 * time.Second) // 2초마다 데이터 수집
	defer ticker.Stop()

	// 네트워크/디스크 속도 계산을 위해 이전 상태 저장
	var prevNetCounters net.IOCountersStat
	var prevDiskCounters map[string]disk.IOCountersStat
	var lastSampleTime time.Time

	// 첫 샘플링
	netCounters, err := getNetCounters()
	if err == nil && len(netCounters) > 0 {
		prevNetCounters = netCounters[0]
	}
	prevDiskCounters, _ = disk.IOCounters()
	lastSampleTime = time.Now()

	for {
		<-ticker.C
		now := time.Now()
		duration := now.Sub(lastSampleTime).Seconds()
		lastSampleTime = now

		var metrics []Metric

		// CPU 정보 (처음 10회 전송, 그 후 30초마다 한 번씩)
		cpuInfoCounter++
		shouldSendCpuInfo := cpuInfoCounter <= 10 || cpuInfoCounter%15 == 0 // 처음 10회 + 30초마다 (15 * 2초)
		
		if shouldSendCpuInfo {
			cpuInfo, err := cpu.Info()
			if err == nil && len(cpuInfo) > 0 {
				cpuMetric := Metric{
					Type:  "cpu_info", 
					Value: float64(cpuInfo[0].Cores),
					Info:  cpuInfo[0].ModelName,
				}
				metrics = append(metrics, cpuMetric)
				log.Printf("Sending CPU info metric (#%d): Type=%s, Value=%.0f, Info=%s", 
					cpuInfoCounter, cpuMetric.Type, cpuMetric.Value, cpuMetric.Info)
			} else {
				log.Printf("Failed to get CPU info: %v", err)
			}
		}

		// CPU
		cpuUsage, err := getCpuUsage()
		if err != nil {
			log.Printf("Error getting CPU usage: %v", err)
		} else {
			metrics = append(metrics, Metric{Type: "cpu", Value: cpuUsage})
		}

		// CPU Core Usage
		coreUsage, err := getCpuCoreUsage()
		if err != nil {
			log.Printf("Error getting CPU core usage: %v", err)
		} else {
			log.Printf("Detected %d CPU cores", len(coreUsage))
			for i, usage := range coreUsage {
				// 코어 번호를 1부터 시작
				metrics = append(metrics, Metric{Type: fmt.Sprintf("cpu_core_%d", i+1), Value: usage})
			}
		}

		// Memory
		memUsage, err := getMemUsage()
		if err != nil {
			log.Printf("Error getting Memory usage: %v", err)
		} else {
			metrics = append(metrics, Metric{Type: "ram", Value: memUsage})
		}

		// Disk I/O
		diskRead, diskWrite, err := getDiskIO(prevDiskCounters, duration)
		if err != nil {
			log.Printf("Error getting Disk IO: %v", err)
		} else {
			metrics = append(metrics, Metric{Type: "disk_read", Value: diskRead})
			metrics = append(metrics, Metric{Type: "disk_write", Value: diskWrite})
			// 다음 계산을 위해 현재 카운터 업데이트
			currentDiskCounters, _ := disk.IOCounters()
			if len(currentDiskCounters) > 0 {
				prevDiskCounters = currentDiskCounters
			}
		}

		// Network I/O
		netSent, netRecv, err := getNetIO(prevNetCounters, duration)
		if err != nil {
			log.Printf("Error getting Net IO: %v", err)
		} else {
			metrics = append(metrics, Metric{Type: "net_sent", Value: netSent})
			metrics = append(metrics, Metric{Type: "net_recv", Value: netRecv})
			// 다음 계산을 위해 현재 카운터 업데이트
			currentNetCounters, _ := getNetCounters()
			if len(currentNetCounters) > 0 {
				prevNetCounters = currentNetCounters[0]
			}
		}

		// TODO: GPU 모니터링 추가 (외부 라이브러리 필요, e.g., NVML for NVIDIA)

		snapshot := &ResourceSnapshot{
			Timestamp: now,
			Metrics:   metrics,
		}

		// 채널로 데이터 전송
		wsChan <- snapshot
		dbChan <- snapshot
	}
}



func getCpuUsage() (float64, error) {
	percentages, err := cpu.Percent(time.Second, false)
	if err != nil || len(percentages) == 0 {
		return 0, err
	}
	return percentages[0], nil
}

func getCpuCoreUsage() ([]float64, error) {
	// 코어별 사용률 측정 (논리 프로세서 개수)
	percentages, err := cpu.Percent(time.Second, true) // true for per-core usage
	if err != nil {
		return nil, err
	}
	
	// CPU 정보 확인
	cpuInfo, err := cpu.Info()
	if err == nil && len(cpuInfo) > 0 {
		log.Printf("CPU Info - Model: %s, Cores: %d, Physical Cores: %d", 
			cpuInfo[0].ModelName, cpuInfo[0].Cores, len(percentages))
	}
	
	return percentages, nil
}

func getMemUsage() (float64, error) {
	v, err := mem.VirtualMemory()
	if err != nil {
		return 0, err
	}
	return v.UsedPercent, nil
}

func getDiskIO(prevCounters map[string]disk.IOCountersStat, duration float64) (readBps, writeBps float64, err error) {
	currentCounters, err := disk.IOCounters()
	if err != nil {
		return 0, 0, err
	}

	var totalRead, totalWrite, prevTotalRead, prevTotalWrite uint64
	for _, c := range currentCounters {
		totalRead += c.ReadBytes
		totalWrite += c.WriteBytes
	}
	for _, p := range prevCounters {
		prevTotalRead += p.ReadBytes
		prevTotalWrite += p.WriteBytes
	}

	if duration > 0 {
		readBps = float64(totalRead-prevTotalRead) / duration
		writeBps = float64(totalWrite-prevTotalWrite) / duration
	}

	return readBps, writeBps, nil
}

func getNetCounters() ([]net.IOCountersStat, error) {
	return net.IOCounters(false) // false: 집계된 카운터
}

func getNetIO(prevCounters net.IOCountersStat, duration float64) (sentBps, recvBps float64, err error) {
	currentCounters, err := getNetCounters()
	if err != nil || len(currentCounters) == 0 {
		return 0, 0, err
	}
	total := currentCounters[0]

	if duration > 0 {
		sentBps = float64(total.BytesSent-prevCounters.BytesSent) / duration
		recvBps = float64(total.BytesRecv-prevCounters.BytesRecv) / duration
	}

	return sentBps, recvBps, nil
}
